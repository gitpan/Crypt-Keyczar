#include "xs/openssl.h"

MODULE = Crypt::Keyczar		PACKAGE = Crypt::Keyczar::AesEngine


Crypt::Keyczar::AesEngine
new(class, key)
	SV *class
	SV *key
	CODE:
	{
	    PERL_UNUSED_VAR(class);
	    Newz(0, RETVAL, 1, struct Crypt__Keyczar__AesEngine_class);
	    Newz(0, RETVAL->context, 1, EVP_CIPHER_CTX);
	    Newz(0, RETVAL->key, SvCUR(key), unsigned char);
	    Newz(0, RETVAL->iv, 16, unsigned char);

	    EVP_CIPHER_CTX_init(RETVAL->context);
	    memmove(RETVAL->key, SvPVbyte_nolen(key), SvCUR(key));
	    RETVAL->key_length = SvCUR(key)*8;
	}
	OUTPUT:
	    RETVAL


void
DESTROY(self)
	Crypt::Keyczar::AesEngine self
	CODE:
	{
	    if (self->context != NULL) {
	        EVP_CIPHER_CTX_cleanup(self->context);
	        Safefree(self->context);
	    }
	    if (self->key != NULL) {
	        Safefree(self->key);
	        self->key = NULL;
	    }
	    if (self->iv != NULL) {
	        Safefree(self->iv);
	        self->iv = NULL;
	    }
	    Safefree(self);
	}


SV *
init(self, ...)
	Crypt::Keyczar::AesEngine self
	CODE:
	{
	    SV *iv;

	    if (items > 1) {
	        iv = ST(1);
	        memmove(self->iv, SvPVbyte_nolen(iv), 16);
	    }
	    else {
	        if (RAND_bytes(self->iv, 16) != 1) {
                    crypt__keyczar__util__croak_openssl();
	            /* NOTREACHED */
	        }	
	    }

	    if (self->iv != NULL) {
	        RETVAL = newSVpv((char *)self->iv, 16);
	    }
	    else {
	        RETVAL = newSVpv("", 0);
	    }
	}
	OUTPUT:
	    RETVAL


SV *
encrypt(self, data)
	Crypt::Keyczar::AesEngine self
	SV *data
	CODE:
	{
	    unsigned char *out;
	    int out_l, last_l;
	    const EVP_CIPHER *type;

	    if (self->key_length == 128) {
	        type = EVP_aes_128_cbc();
	    }
	    else if (self->key_length == 192) {
	        type = EVP_aes_192_cbc();
	    }
	    else if (self->key_length == 256) {
	        type = EVP_aes_256_cbc();
	    }
	    else {
	        croak("unsupported key length: %d", self->key_length);
	    }

	    EVP_EncryptInit_ex(self->context, type, NULL, self->key, self->iv);
	    Newz(0, out, SvCUR(data) + EVP_CIPHER_CTX_block_size(self->context), unsigned char);
	    EVP_EncryptUpdate(self->context, out, &out_l, (unsigned char *)SvPVbyte_nolen(data), SvCUR(data));
	    EVP_EncryptFinal_ex(self->context, out + out_l, &last_l);
	    out_l += last_l;
	    RETVAL = newSVpv((char *)out, out_l);
	    Safefree(out);
	}
	OUTPUT:
	    RETVAL


SV *
decrypt(self, data)
	Crypt::Keyczar::AesEngine self
	SV *data
	CODE:
	{
	    unsigned char *out;
	    int out_l, last_l;
	    const EVP_CIPHER *type;

	    if (self->key_length == 128) {
	        type = EVP_aes_128_cbc();
	    }
	    else if (self->key_length == 192) {
	        type = EVP_aes_192_cbc();
	    }
	    else if (self->key_length == 256) {
	        type = EVP_aes_256_cbc();
	    }
	    else {
	        croak("unsupported key length: %d", self->key_length);
	    }

	    Newz(0, out, SvCUR(data), unsigned char);
	    EVP_DecryptInit_ex(self->context, type, NULL, self->key, self->iv);


	    EVP_DecryptUpdate(self->context, out, &out_l, (unsigned char *)SvPVbyte_nolen(data), SvCUR(data));
	    EVP_DecryptFinal_ex(self->context, out + out_l, &last_l);
	    out_l += last_l;

	    RETVAL = newSVpv((char *)out, out_l);
	    Safefree(out);
	}
	OUTPUT:
	    RETVAL
